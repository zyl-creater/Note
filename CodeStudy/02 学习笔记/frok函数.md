# 1. fork

fork()函数通过系统调用创建一个与原来进程（父进程）几乎完全相同的进程（子进程是父进程的副本，它将获得父进程数据空间、堆、栈等资源的副本。注意，子进程持有的是上述存储空间的“副本”，这意味着父子进程不共享这些存储空间。linux将复制父进程的地址空间内容给子进程，因此，子进程由了独立的地址空间。），也就是这两个进程做完全相同的事。但如果初始参数或者传入的变量不同，两个进程也可以做不同的事。 ^3f3cb6

一个进程调用fork（）函数后，系统先给新的进程分配资源，例如存储数据和代码的空间。然后把原来的进程的所有值都复制到新的新进程中，只有少数值与原来的进程的值不同。相当于克隆了一个自己。

我们来看一个例子：
fork_test.c
```c
#include <unistd.h>
#include <stdio.h>

int main()
{
  pid_t fpid; //fpid表示fork函数返回的值
  int count=0;
  fpid=fork();
  if (fpid < 0)
  printf("error in fork!");
  else if (fpid == 0){
    printf("i am the child process, my process id is %d\n",getpid());
    printf("我是爹的儿子\n");
    count++;
  }
  else{
    printf("i am the parent process, my process id is %d\n",getpid());
    printf("我是孩子他爹\n");
    count++;
  }
  printf("统计结果是: %d\n",count);
  return 0;
}
```

运行结果是：
```
i am the parent process, my process id is 12198
我是孩子他爹
统计结果是: 1
i am the child process, my process id is 12199
我是爹的儿子
统计结果是: 1
```

关于此函数的说明：

1、调用一次，返回两次，fork()函数被父进程调用一次，但返回两次，一次是返回到父进程中(调用进程)，一次是返回到新创建的子进程中。在父进程中，fork返回子进程的PID，在子进程中，fork返回0，因为子进程的Pid总是非零，返回值就提供一个明确的方法判断程序是在父进程还是在子进程中。
2、并发执行：父进程和子进程是并发运行的独立进程，内核能以任意方式交替执行它们的逻辑控制流中的指令。
3、相同的但是独立的地址空间，因为父进程与子进程都是独立的进程，它们有自己的私有地址空间，父进程和子进程对count的修改都是独立的，不会反映在另一个进程的存储器中。 ^4248ff

在语句 fpid=fork() 之前，只有一个进程在执行这段代码，但在这条语句之后，就变成两个进程在执行了，这两个进程的几乎完全相同，将要执行的下一条语句都是if(fpid<0)……  
为什么两个进程的fpid不同呢，这与 fork 函数的特性有关。fork调用的一个奇妙之处就是它仅仅被调用一次，却能够返回两次，它可能有三种不同的返回值：  
1）在父进程中，fork返回新创建子进程的进程ID；  
2）在子进程中，fork返回0；  
3）如果出现错误，fork返回一个负值；

在[[fork进阶#^e3cfb4|fork函数执行完毕后，如果创建新进程成功]]，则出现两个进程，一个是子进程，一个是父进程。在子进程中，fork函数返回0，在父进程中，fork返回新创建子进程的进程ID。我们可以通过fork返回的值来判断当前进程是子进程还是父进程。

fpid的值为什么在父子进程中不同。其实就相当于链表，进程形成了链表，父进程的fpid(p 意味point)指向子进程的进程id, 因为子进程没有子进程，所以其fpid为0.

# 2. fork出错可能有两种原因：
1、当前的进程数已经达到了系统规定的上限，这时errno的值被设置为EAGAIN。
2、系统内存不足，这时errno的值被设置为ENOMEM。

创建新进程成功后，系统中出现两个基本完全相同的进程，这两个进程执行没有固定的先后顺序，哪个进程先执行要看系统的进程调度策略。

每个进程都有一个独特（互不相同）的进程标识符（process ID），可以通过getpid（）函数获得，还有一个记录父进程pid的变量，可以通过getppid（）函数获得变量的值。fork执行完毕后，出现两个进程
![[Pasted image 20220801191945.png]]

有人说两个进程的内容完全一样啊，怎么打印的结果不一样啊，那是因为判断条件的原因，上面列举的只是进程的代码和指令，还有变量

执行完fork后，进程1的变量为count=0，fpid！=0（父进程）。进程2的变量为count=0，fpid=0（子进程），这两个进程的变量都是独立的，存在不同的地址中，不是共用的，这点要注意。可以说，我们就是通过fpid来识别和操作父子进程的。

还有人可能疑惑为什么不是从#include处开始复制代码的，这是因为fork是把进程当前的情况拷贝一份，执行fork时，进程已经执行完了int count=0; fork只拷贝下一个要执行的代码到新的进程。

# 3. fork的执行过程：
(1)申请PID
(2)申请PCB结构
(3)复制父进程的PCB
(4)将子进程的运行状态设置为不可执行的
(5)将子进程中的某些属性清零，某些保留，某些修改
(6)复制父进程的页（用到了写时拷贝技术）

这里所用到的**写时拷贝技术**指的是父子进程在初始阶段共享所有的数据（全局、栈区、堆区、代码），内核会将所有的区域设置为只读。当父子进程中任意一个进程试图修改其中的数据时，内核才会将要修改的数据所在的区域（页）拷贝一份。即创建子进程的时候，并不 copy 父进程的地址空间，父子进程拥有共同的地址空间，只有当子进程需要写入数据时（如向缓冲区写入数据），这时候会复制地址空间，复制缓冲区到子进程中去。从而父子进程拥有独立的地址空间

写时拷贝技术针对的是：fork 之后，子进程往往会替换成新的程序，所以在 fork 的时候就不需要将父进程完全拷贝出来，当替换新程序时，直接给子进程重新分配空间即可。
 
父子进程建数据共享问题：.data   .bss   .text   .heap的数据都不共享，但是父子进程之间共享 fork 之前打开的文件描述符，并且父子进程共用文件读写偏移量。原理如图所示：
![[Pasted image 20220801200723.png]]

所以， 在执行逻辑上， fork 之前打开的文件， 要 close 两次！！

# 注意：在调用fork()执行后，可能会产生孤儿进程和僵尸进程

孤儿进程： 父进程结束， 子进程依旧存在。 那么子进程就被称为孤儿进程。 系统会将所有的孤儿进程挂载到 init 下。 init 进程的 pid = 1 ^5cc5bc

僵尸进程： 1，进程结束， 但是 PCB 没释放,2，子进程结束， 父进程未结束， 并且父进程未获取子进程的退出状态

处理僵尸进程方法：
1、 结束其父进程。
2、 父进程获取子进程的退出状态： 在父进程中调用wait()函数，但是wait 函数会阻塞运行， 直到第一个子进程退出。
3、在子进程结束时，子进程给父进程发一个信号(告知父进程我已经结束了)父进程接收到信号后在对子进程做处理
